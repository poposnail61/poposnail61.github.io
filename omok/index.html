<!DOCTYPE html>
<html lang="kr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { display:flex; justify-content:center; align-items:center; height:100vh; margin:0; background:#f0f0f0; font-family:sans-serif; }
    canvas { background:#deb887; box-shadow:0 0 10px rgba(0,0,0,0.5); }
  </style>
  <title>Omok</title>
</head>
<body>
  <canvas id="board"></canvas>
<script>
const boardSize = 15;
const cellSize = 30;
const canvas = document.getElementById('board');
canvas.width = canvas.height = boardSize * cellSize;
const ctx = canvas.getContext('2d');
let board = Array.from({length: boardSize}, () => Array(boardSize).fill(0));
let gameOver = false;
let lastUserMove = null;
let lastAiMove = null;

function drawBoard(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle = '#000';
  for(let i=0;i<boardSize;i++){
    ctx.beginPath();
    ctx.moveTo(cellSize/2, cellSize/2 + i*cellSize);
    ctx.lineTo(canvas.width - cellSize/2, cellSize/2 + i*cellSize);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cellSize/2 + i*cellSize, cellSize/2);
    ctx.lineTo(cellSize/2 + i*cellSize, canvas.height - cellSize/2);
    ctx.stroke();
  }
  for(let y=0;y<boardSize;y++){
    for(let x=0;x<boardSize;x++){
      if(board[y][x]) drawStone(x,y,board[y][x]);
    }
  }
}

function drawStone(x,y,player){
  ctx.beginPath();
  ctx.arc(x*cellSize + cellSize/2, y*cellSize + cellSize/2, cellSize*0.4, 0, Math.PI*2);
  if(player===1){
    const isLast = lastUserMove && lastUserMove.x===x && lastUserMove.y===y;
    ctx.fillStyle = isLast ? '#333' : '#000';
  }else{
    const isLast = lastAiMove && lastAiMove.x===x && lastAiMove.y===y;
    ctx.fillStyle = isLast ? '#eee' : '#fff';
  }
  ctx.strokeStyle = '#000';
  ctx.fill();
  ctx.stroke();
}

function checkWin(x,y,player){
  const dirs=[[1,0],[0,1],[1,1],[1,-1]];
  for(const [dx,dy] of dirs){
    let count=1;
    for(const dir of [1,-1]){
      let nx=x+dx*dir, ny=y+dy*dir;
      while(nx>=0 && nx<boardSize && ny>=0 && ny<boardSize && board[ny][nx]==player){
        count++; nx+=dx*dir; ny+=dy*dir;
      }
    }
    if(count>=5) return true;
  }
  return false;
}

function scorePoint(x,y,player){
  const dirs=[[1,0],[0,1],[1,1],[1,-1]];
  let score=0;
  for(const [dx,dy] of dirs){
    let count=1;
    for(const dir of [1,-1]){
      let nx=x+dx*dir, ny=y+dy*dir;
      while(nx>=0 && nx<boardSize && ny>=0 && ny<boardSize && board[ny][nx]==player){
        count++; nx+=dx*dir; ny+=dy*dir;
      }
    }
    score=Math.max(score,count);
  }
  return Math.pow(10,score);
}

function aiMove(){
  let best=null, bestScore=-1;
  for(let y=0;y<boardSize;y++){
    for(let x=0;x<boardSize;x++){
      if(board[y][x]) continue;
      let s = scorePoint(x,y,2) + scorePoint(x,y,1)*0.8;
      if(s>bestScore){ bestScore=s; best={x,y}; }
    }
  }
  if(best){
    board[best.y][best.x]=2;
    lastAiMove={x:best.x,y:best.y};
    if(checkWin(best.x,best.y,2)){ drawBoard(); alert('AI wins!'); gameOver=true; return; }
  }
  drawBoard();
}

canvas.addEventListener('click', e=>{
  if(gameOver) return;
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX-rect.left)/cellSize);
  const y = Math.floor((e.clientY-rect.top)/cellSize);
  if(x<0||x>=boardSize||y<0||y>=boardSize||board[y][x]) return;
  board[y][x]=1;
  lastUserMove={x,y};
  drawBoard();
  if(checkWin(x,y,1)){ alert('You win!'); gameOver=true; return; }
  setTimeout(()=>{ if(!gameOver) aiMove(); }, 500);
});

drawBoard();
</script>
</body>
</html>
